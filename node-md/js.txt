ECMAScript、Javascript、nodejs
ecmascript:简称es，是一个语言标准
javascript:运行在浏览器的语言，改语言使用es标准，e+web api = javascript
nodejs: 运行在服务端的语言，该语言使用es标准es+node api
 es3 1999年
 es5 2009年
 es6 2015年 从该版本开始，不再使用数字作为编号，使用年份
 es7 2016年

 es6解决js无法开发大型应用的语言层面的问题

 兼容性问题如何解决？

声明变量的问题
var
    使用var声明变量：
    允许重复的变量声明，导致数据被覆盖
    变量提升，怪异的数据访问，闭包问题
    全局变量挂在到全局对象，全局对象成员污染问题
let
    let声明的变量不会挂在到全局
    let声明的变量，不允许当前作用于范围内重复声明
    es6中,引入let关键字用于解决变量声明的问题，同时引入了块级作用域的概念
    块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域
    在块级作用域中用let定义的变量，在作用域外不能访问
    使用let不会有变量提升，因此，不能在定义let变量之前使用它
    底层实现上，let声明的变量实际上也会有提升，但是，提升后会将其放入到‘暂时性死去’，如果访问的变量位于暂时性死去，则会报错
    当代码运行到该变量声明的语句时，会将其从暂时性 死区中移除
    eg:循环中，每次循环创建一个新的块级作用域，循环结束，块级作用域销毁
const
    const和let完全相同，仅在于const声明的变量，必须在声明时赋值，而且不可以重新赋值
    实际上，在开发中，应尽量使用const来声明变量，以保证变量的值不会随意篡改
    注意细节：
        1.常量不可变，是指声明的常量的内存空间不可变，并不保证内存空间中的地址指向的其他空间不可变
        2.常量的命名
            1.特殊的常量：该常量从字面意义上，一定是不可变的，比如圆周率等。命名规则通常为全部大写
            2.普通常量随意
        3.在循环中不能使用常量进行循环
            不允许 for(const i = 0; i < 10; i++)
            允许 for(const props in obj) 


新的字符串操作api
includes
startsWith
endWith
repeat

正则表达式
    粘连标记 y
    匹配时，完全按照正则对象中的lastIndex位置开始匹配，并且匹配的位置必须在lastIndex位置

模板字符串`${表达式}`
1.多行字符串
2.拼接字符串   
3.模板字符串的标记
    标记名`模板字符串`
    1.参数1：被插值分割的字符串数组
    2.后续参数：所有的插值
    String.raw
    eg:
        对用户输入进行控制
        function safe(parts){
            const values = Array.prototype.slice.apply(this).slice(1)
            for let i= 0; i < values. length; i++) {
                const= values [i]. replace(/</g, "&It;").replace(/>/g, "&gt;");
                str+=parts [i] + v;
            if (i=== values.length-1） ｛
                str+= parts[i + 1];
            }
            return str;
        } 


参数默认值
    在书写形参时，直接给形参赋值，附的值即为默认值
    这样一来，当调用函数时，如果没有给对应的参数赋值，给他它的值是undefined，则会自动使用默认值
    对arguments的影响
        只要给函数加上参数默认值，该函数会自动变成严格模式下的规则：arguments和形参脱离
    暂时性死区
        形参和es6中的let和const声明一样，具有作用域，并且更具参数的声明顺序，存在暂时性死区

剩余参数（平时写公共函数可以使用）
    arguments的缺陷
        1.如果和形参配合使用，容易导致混乱
        2.从语义上，使用arguments获取参数，用于形参缺失，无法从函数定义上理解函数真实意图

        es6的剩余参数专门用于收集末尾的参数，把它放到一个数组中
        1.一个函数，仅能出现一个剩余参数
        2.一个函数，如果有剩余参数，剩余参数必须是最后一个参数

展开运算符（可以进行数组和对象的浅拷贝）
    对数组展开es6
    对对象展开es7
柯里化
    用于固定某特函数的前面的参数，得到一个新的函数

明确函数的双重用途
    es6提供了一个特殊的api，可以使用该api在函数内部，判断该函数是否使用了new来调用
    new.target
        该表达式，得到的是：如果没有使用new来调用函数，则返回undefined
        如果使用new调用函数，则得到的是new关键字后面的函数本身



浅拷贝
深拷贝
